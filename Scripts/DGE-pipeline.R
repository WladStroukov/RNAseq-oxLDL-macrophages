#' Differential gene expression analysis pipeline of oxLDL-treated M2 macrophages vs untreated M2 macrophages


# Clear environment
rm(list = ls())


#### Libraries ####

# ## Data wrangling
library(tidyverse)         # Data wrangling, piping operator: %>% 
# 
# ## DGE analysis
library(DESeq2)             
library(factoextra)       # Screeplots (PCA) 
# library(ashr)             # LFC shrinkage  
# 
# ## Visualisation
library(ggplot2)        # main package for visualisation
library(scales)           # for scaling values (used for visualisations, etc.)
library(vsn)            # for meanSdPlot()
library(pheatmap)       # Heatmaps
# library(gridExtra)        # to arrange heatmaps in a grid. Alternative to patchwork
# library(ggrepel)          # Labeling      
# library(RColorBrewer)       
# library(viridis)          # colour scheme (incl Inferno)  
# library(VennDiagram)
# library(patchwork)        # display of multiple plots and simple arrangements: p1 + p2
# 
# 
# 
# ## Annotation
# #library(tximport)         # For transcript database?
library(GenomicFeatures)  # Import GTF file data for annotation, for makeTxDbFromGFF 
library(biomaRt)          # Main annotation package
# #library(AnnotationDbi)    # Annotation - mapIds() function, automatically loaded when using library(GenomicFeatures) 



##### Utility functions ####

makePCAplot <- function(mat, sampleTable, PC.x = 1, PC.y = 2, colorby="Condition", main="PCA-plot"){
  #' Perform and plot PCA of count matrix.
  #' Requires transformed count matrix (e.g. VST transformation)
  #' @param mat Array, 2D matrix with GeneIDs as rows and samples as columns 
  #' @param sampleTable DataFrame, Table containing the sample information/meta data of the sequencing. 
  #' @param PC.x Numeric, Principal component on x-axis. [Default: 1]
  #' @param PC.y Numeric, Principal component on y-axis. [Default: 2]
  #' @param colorby Character, [Default: "condition"]
  #' @param main Character, title of plot. [Default: "PCA-plot"]
  #' @examples 
  #' makePCAplot(vsd_matrix, PC.x = 2, PC.y = 3, colorby = "treatment", main = "PCA plot by Treatment")
  
  # Prepare PCA data
  pca <- prcomp(t(mat)) # compute PCA
  df.pca <- cbind(sampleTable, pca$x)
  
  
  # get proportion of Variance
  var.pcx <- round(summary(pca)$importance[2,PC.x]*100 , 1) # % variance of PCx
  var.pcy <- round(summary(pca)$importance[2,PC.y]*100 , 1) # % variance of PCy
  
  # plot PCA results
  PC.x = paste0("PC", PC.x)
  PC.y = paste0("PC", PC.y)
  pca_plot <- ggplot(df.pca, aes_string(x = PC.x, y = PC.y, color= colorby))
  pca_plot + labs(color = colorby) + geom_point(size=5) + ggtitle(main) +
    labs(fill = colorby) +
    xlab(paste0(PC.x, " (", var.pcx,"% variance)")) +    
    ylab(paste0(PC.y ," (", var.pcy,"% variance)")) +  
    coord_fixed() +
    xlim(-100,100) +
    ylim(-100,100) +
    theme_bw() +
    scale_color_manual(values=c("#8cafc8", "#eb9282", "#ebb573")) +
    theme(panel.grid.major = element_blank(),panel.grid.minor = element_blank())
}


annotateResults <- function(res, mergeon="ensembl_gene_id", anno){
  #' Join biomart annotation table to extracted DESeq2 results table. 
  #' In case of duplicated entries only the first entry will be kept, remaining rows will be dropped.
  #' @param res DESeqResults object; Must contain Ensembl IDs as rownames.
  #' @param mergeon Character; Column name to be merged on. [Default: ensembl_gene_id]
  #' @param anno Data.frame; Annotation table generated by BiomaRt.
  #' @return 
  #' @examples
  #' annotateResults(res.TreatedvsUntreated, mergeon="ensembl_gene_id", anno=biomart.annotation)
  res <- as.data.frame(res) %>% 
    rownames_to_column(mergeon) %>% 
    left_join(annotation, mergeon)
  res <- res[!duplicated(res[,mergeon]), ]  # Keep the first row of duplicated entries in the merge on column.  
  rownames(res) <- res[,mergeon]            # Use Ensembl IDs as row names again
  res[,mergeon] <- NULL                     # Remove redundant Ensembl ID column
  return(res)
}



getSigDEGs <- function(res, padj.cutoff=0.05, save=F, wd="./", filename="Significant_DEGs"){
  #' Return significant differentially expressed genes from DESeq2 results ordered by adjusted p-value.
  #' Requires two columns: 'log2FoldChange' and 'padj'
  #' @param res Dataframe, Table with DESeq results
  #' @param padj.cutoff Numeric, Adjusted p-value cutoff. [Default: 0.05]  
  #' @param save Character, Save significant DEGs as csv file. [Default: False]
  #' @param wd Character, directory into which the file will be saved. [Default: "./"]
  #' @param filename Character, file name. [Default: "Significant_DEGs"]
  #' @examples
  #' getSigDEGs(res.TreatedvsUntreated, padj=0.05, save=TRUE, wd="./results/", filename="TreatedvsUntreated")
  if(!class(res)=="data.frame"){
    res <- as.data.frame(res)
  }
  res.sig <- subset(res, padj < padj.cutoff)
  res.ordered_p <- res.sig[order(res.sig$padj),]
  res.up <- res.ordered_p[ res.ordered_p[,"log2FoldChange"] > 0, ]
  res.down <- res.ordered_p[ res.ordered_p[,"log2FoldChange"] < 0, ]
  n_UpReg <- nrow(res.up)
  n_DownReg <- nrow(res.down)
  topResults <- rbind(res.up[1:n_UpReg, ], res.down[n_DownReg:1, ])
  
  if(save){
    write.csv(topResults, paste0(wd,Sys.Date(),"_SigDEGs_padj-",padj.cutoff,"_", filename,".csv"))
  }
  return(topResults)  
}






#### Loading data ####
#' Processing of RNAseq data prior to import into DESeq2 using STAR 2.7.3a and featureCounts (from subread 2.0.2). 
#' No trimming was performed. QC performed by novogone

# Metadata/ Sample Table 
colData <- data.frame(
  Sample = factor(c('A03_M2', 'A03_MOX', 
                    'A04_M2', 'A04_MOX',
                    'S02_M2', 'S02_MOX')),
  Condition = factor(rep(c('M2',"MOX"), 3)),
  Donor = factor(c('A03', 'A03', 
                   'A04', 'A04', 
                   'S02', 'S02'))
)
rownames(colData) <- colData$Sample 

# Count matrix
cts <- as.matrix(read.csv("../data/countmatrix.txt", sep="\t",row.names="Geneid"))
colnames(cts) <- colData$Sample # change the long sample names to short sample names
print(paste("Full data set:", all(rownames(colData) %in% colnames(cts)))) # Checking if the sampleTable and count matrix annotations correspond to each other



#### Running differential expression analysis ####
# Parsing count matrix to DESeq2 dataset
ddsCts <- DESeqDataSetFromMatrix(countData = cts,
                                 colData = colData,
                                 design = ~Donor + Condition)
# Running DESeq analysis
dds <- DESeq(ddsCts)


#### Assessing data ####
## Transformation for data set: Variance stabilized transformation
vsd <- vst(dds, blind=TRUE)
vsd_mat <- assay(vsd)


## Per gene standard deviation
# Plotting the per-gene standard deviation (SD, taken across samples) against the rank of the mean for the the variance-stabilizing transformation(vst)
vsd_msd <- meanSdPlot(vsd_mat, ylab="Standard deviation (vst)", plot=FALSE)

png(paste0("../Results/",Sys.Date(),"_VST-Transformation.png"), width=400, height=350 )
vsd_msd$gg + ggtitle("Per gene standard deviation (VST)")
dev.off()


## Hierarchical clustering of samples
vsd_cor  <- cor(vsd_mat)#Computing the pairwise correlation values for transformed counts.


annotation <- data.frame(Condition = c(rep(c("M2","MOX"), 3) ))# Preparing annotations and labeling.
rownames(annotation) <- colnames(vsd_cor) #all matrices have the same rownames. Note that the rownames are colnames in the correlation matrix
#rownames(annotation) <- colData[["Sample"]]
#annotation
ann_colors = list(Condition = c(M2 ="#eb9282", MOX ="#8cafc8"))  # RA ="#ebb573", PopS ="#eb9282", RO ="#8cafc8"

png(paste0("../Results/",Sys.Date(),"_Hierarchical-sample-clustering.png"), width=400, height=300 )
pheatmap(vsd_cor, annotation = annotation, annotation_colors = ann_colors, main = "VST transformed",  silent=F)
dev.off()

## Principal component analysis
pca <- prcomp(t(vsd_mat)) # compute PCA
fviz_screeplot(pca, addlabels = T) + ylim(0,100) + theme_classic() + labs(title = "Variances - PCA (VST transformated counts)\n(Full)", x = "Principal components", y = "% of variance") # Screeplot visualizes the variances accross the different PCs


# Plots of genes contributing to variance for the individual PCs
# PC1
fviz_contrib(pca, choice = "var", axes = 1, top = 15) + 
  theme_classic() + 
  labs(title = "Contribution to PC1", x = "Genes", y = "Contribution (%)") +
  theme(axis.text.x = element_text(angle = 90))

# PC2
fviz_contrib(pca, choice = "var", axes = 2, top = 15) + 
  theme_classic() + 
  labs(title = "Contribution to PC2", x = "Genes", y = "Contribution (%)") +
  theme(axis.text.x = element_text(angle = 90))

# PC3
fviz_contrib(pca, choice = "var", axes = 3, top = 15) + 
  theme_classic() + 
  labs(title = "Contribution to PC3", x = "Genes", y = "Contribution (%)") +
  theme(axis.text.x = element_text(angle = 90))


# PCA plots
png(paste0("../Results/",Sys.Date(),"PCA_PC1+PC2_condition.png"), width=300, height=275 )
makePCAplot(mat=vsd_mat, sampleTable = colData, colorby="Condition", PC.x = 1, PC.y = 2, main = "PC1 and PC2 by condition")
dev.off()

png(paste0("../Results/",Sys.Date(),"PCA_PC1+PC2_donor.png"), width=300, height=275 )
makePCAplot(mat=vsd_mat, sampleTable = colData, colorby="Donor", PC.x = 1, PC.y = 2, main = "PC1 and PC2 by donor")
dev.off()

png(paste0("../Results/",Sys.Date(),"PCA_PC1+PC3_condition.png"), width=300, height=275 )
makePCAplot(mat=vsd_mat, sampleTable = colData, colorby="Condition", PC.x = 1, PC.y = 3, main = "PC1 and PC3 by condition")
dev.off()

png(paste0("../Results/",Sys.Date(),"PCA_PC1+PC3_donor.png"), width=300, height=275 )
makePCAplot(mat=vsd_mat, sampleTable = colData, colorby="Donor", PC.x = 1, PC.y = 3, main = "PC1 and PC3 by donor")
dev.off()




## Diagnostic plots
# Cooks distances
png(paste0("../Results/",Sys.Date(),"_Cooks-distance.png"), width=300, height=275 )
par(mar=c(5,5,1,1))
boxplot(log10(assays(dds)[["cooks"]]), range=0, las=1, main="Cook's distance")
dev.off()

# Dispersion estimates
png(paste0("../Results/",Sys.Date(),"_Dispersion-estimates.png"), width=300, height=275 )
par(mar=c(5,5,2,2))
plotDispEsts(dds) 
title("Dispersion estimates")
dev.off()


#### DGE results ####

## Verifying size factors
design <- design(dds)
print(paste("Design: ~", design[2]))
sizefactors <- sizeFactors(dds)
print("Size factors:")
print(sizefactors)

## Setting contrast and extracting results
contrast <- c("Condition", "MOX","M2")
padj = 0.05
res.unshrunken <- results(dds,  contrast = contrast,  alpha = padj)

# Summary oxLDL-treated M2 macrophages vs untreated M2 macrophages")
summary(res.unshrunken) 


## LFC shrinkage
res.ashr  <- lfcShrink(dds, type = "ashr", contrast=contrast,  res = res.unshrunken) 

#' DrawMAPlot functions cuts of all values with padj = NA, but for this plot they should be included. Add an addtional condition that plots values with NA in grey (or other colour)

DrawMAPlot <- function(res, main="",padj=0.05, xlab="Mean of normalized counts", ylab=expression(log[2]~fold~change), ylim=c(-2,2)){
  #' Draws an MA plot showing the log2 fold changes attributable to a given variable over the mean of normalized counts for all the samples in a DESeqDataSet.
  #' @param res DESeqDataSet, Extracted results from DESeqDataSet using the results() function after DESeq analysis was performed.
  #' @param main String; Title of the Plot [Default: ""]
  #' @param padj Double; Adjusted p-value. [Default: 0.05]
  #' @param xlab String; Title of x label. [Default: "Mean of normalized counts"]
  #' @param ylab String or Expression; Title of y label [Default: expression(log[2]~fold~change)]
  #' @param ylim Integer or double; Limits of the y axis [Default: 2]
  #' @examples
  #' DrawMAPlot(res=res.TvsUn, main="Treated vs Untreated (ashr)")
  res.df <- as.data.frame(res)
  ggplot(data = res.df,aes(x = baseMean, y = log2FoldChange)) +
    geom_point(color = ifelse(res.df$padj < padj, "red", "grey20"),  # add condition for padj = NA
               alpha = ifelse(res.df$padj < padj, 0.5, 0.2),         # add condition for padj = NA
               shape = 16) +
    scale_x_log10(limits=c(1,1000000), breaks = trans_breaks("log10", function(x) 10^x),labels = trans_format("log10", math_format(10^.x))) +
    labs(x = xlab, y = ylab) +
    ylim(ylim) +
    geom_hline(yintercept=0, linetype="dashed", color = "black",size=1) +
    theme_bw() + 
    ggtitle(main)
}



plotMA(res.unshrunken, ylim=c(-6,6)) + title("MA plot (unshrunken)")
plotMA(res.ashr, ylim=c(-6,6))  + title("MA plot (shrunken)")


# clean NA values from data
res  <- na.omit(res.ashr)



## Annotation
ensembl <- useEnsembl(biomart = "genes",
                      dataset = "hsapiens_gene_ensembl",
                      version = 104) # the same version used as reference genome for alignment with STAR

# Query biomart for annotation
#' Add information on how and where to get the gtf file from
#' Creating the transcript database for annotation
gtffile <- "../data/Homo_sapiens.GRCh38.104.gtf.gz"  
txdb <- makeTxDbFromGFF(gtffile,
                        format="auto",
                        dataSource="ensembl.org GRCh38.p13 release 104",
                        organism="Homo sapiens")

attributes <- c("ensembl_gene_id","hgnc_symbol","entrezgene_id","chromosome_name","gene_biotype","description")
GeneIDs <- keys(txdb, keytype="GENEID") # txdb has been generated from from the GFF file corresponding to the reference genome used for alignment

annotation <- getBM(attributes = attributes,
                    filters = c("ensembl_gene_id"),
                    values = GeneIDs,
                    mart = ensembl)

res.anno  <- annotateResults(res, anno=annotation) # custom function


## Filtering and sorting of significant genes
res.sig  <- getSigDEGs(res.anno,  padj.cutoff=padj, save=T, wd="../results/", filename="Treg_MOX-vs-M2")
#View(res.sig)
