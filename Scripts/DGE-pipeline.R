#' Differential gene expression analysis pipeline of oxLDL-treated M2 macrophages vs untreated M2 macrophages


# Clear environment
rm(list = ls())


#### Libraries ####

# ## Data wrangling
library(tidyverse)         # Data wrangling, piping operator: %>% 
# 
# ## DGE analysis
library(DESeq2)             
library(factoextra)       # Screeplots (PCA) 
# library(ashr)             # LFC shrinkage  
# 
# ## Visualisation
library(ggplot2)        # main package for visualisation
library(scales)           # for scaling values (used for visualisations, etc.)
library(vsn)            # for meanSdPlot()
library(pheatmap)       # Heatmaps
library(RColorBrewer)   # colors for heatmap

# library(gridExtra)        # to arrange heatmaps in a grid. Alternative to patchwork
library(ggrepel)          # Labeling in heatmap      
library(viridis)          # colour scheme (used in GO enrichment plots) 
# library(VennDiagram)
# library(patchwork)        # display of multiple plots and simple arrangements: p1 + p2
# 
# ## Annotation
# #library(tximport)         # For transcript database?
library(GenomicFeatures)  # Import GTF file data for annotation, for makeTxDbFromGFF 
library(biomaRt)          # Main annotation package
# #library(AnnotationDbi)    # Annotation - mapIds() function, automatically loaded when using library(GenomicFeatures) 
library(org.Hs.eg.db)     # Annotation for functional analysis with cluster profiler

# Functional analysis
library(clusterProfiler)  # Functional analysis: Enrichments 
library(msigdbr)          # MSigDB
library(enrichplot)       # Visualisations: gseaplot2, dotplot, Treeplot, enrichmentmaps, (pairwise_termsim) etc




##### Utility functions ####

makePCAplot <- function(mat, sampleTable, PC.x = 1, PC.y = 2, colorby="Condition", main="PCA-plot"){
  #' Perform and plot PCA of count matrix.
  #' Requires transformed count matrix (e.g. VST transformation)
  #' @param mat Array, 2D matrix with GeneIDs as rows and samples as columns 
  #' @param sampleTable DataFrame, Table containing the sample information/meta data of the sequencing. 
  #' @param PC.x Numeric, Principal component on x-axis. [Default: 1]
  #' @param PC.y Numeric, Principal component on y-axis. [Default: 2]
  #' @param colorby Character, [Default: "condition"]
  #' @param main Character, title of plot. [Default: "PCA-plot"]
  #' @examples 
  #' makePCAplot(vsd_matrix, PC.x = 2, PC.y = 3, colorby = "treatment", main = "PCA plot by Treatment")
  
  # Prepare PCA data
  pca <- prcomp(t(mat)) # compute PCA
  df.pca <- cbind(sampleTable, pca$x)
  
  
  # get proportion of Variance
  var.pcx <- round(summary(pca)$importance[2,PC.x]*100 , 1) # % variance of PCx
  var.pcy <- round(summary(pca)$importance[2,PC.y]*100 , 1) # % variance of PCy
  
  # plot PCA results
  PC.x = paste0("PC", PC.x)
  PC.y = paste0("PC", PC.y)
  pca_plot <- ggplot(df.pca, aes_string(x = PC.x, y = PC.y, color= colorby))
  pca_plot + labs(color = colorby) + geom_point(size=5) + ggtitle(main) +
    labs(fill = colorby) +
    xlab(paste0(PC.x, " (", var.pcx,"% variance)")) +    
    ylab(paste0(PC.y ," (", var.pcy,"% variance)")) +  
    coord_fixed() +
    xlim(-100,100) +
    ylim(-100,100) +
    theme_bw() +
    scale_color_manual(values=c("#8cafc8", "#eb9282", "#ebb573")) +
    theme(panel.grid.major = element_blank(),panel.grid.minor = element_blank())
}


annotateResults <- function(res, mergeon="ensembl_gene_id", anno){
  #' Join biomart annotation table to extracted DESeq2 results table. 
  #' In case of duplicated entries only the first entry will be kept, remaining rows will be dropped.
  #' @param res DESeqResults object; Must contain Ensembl IDs as rownames.
  #' @param mergeon Character; Column name to be merged on. [Default: ensembl_gene_id]
  #' @param anno Data.frame; Annotation table generated by BiomaRt.
  #' @return 
  #' @examples
  #' annotateResults(res.TreatedvsUntreated, mergeon="ensembl_gene_id", anno=biomart.annotation)
  res <- as.data.frame(res) %>% 
    rownames_to_column(mergeon) %>% 
    left_join(annotation, mergeon)
  res <- res[!duplicated(res[,mergeon]), ]  # Keep the first row of duplicated entries in the merge on column.  
  rownames(res) <- res[,mergeon]            # Use Ensembl IDs as row names again
  res[,mergeon] <- NULL                     # Remove redundant Ensembl ID column
  return(res)
}



getSigDEGs <- function(res, padj.cutoff=0.05, save=F, wd="./", filename="Significant_DEGs"){
  #' Return significant differentially expressed genes from DESeq2 results ordered by adjusted p-value.
  #' Requires two columns: 'log2FoldChange' and 'padj'
  #' @param res Dataframe, Table with DESeq results
  #' @param padj.cutoff Numeric, Adjusted p-value cutoff. [Default: 0.05]  
  #' @param save Character, Save significant DEGs as csv file. [Default: False]
  #' @param wd Character, directory into which the file will be saved. [Default: "./"]
  #' @param filename Character, file name. [Default: "Significant_DEGs"]
  #' @examples
  #' getSigDEGs(res.TreatedvsUntreated, padj=0.05, save=TRUE, wd="./results/", filename="TreatedvsUntreated")
  if(!class(res)=="data.frame"){
    res <- as.data.frame(res)
  }
  res.sig <- subset(res, padj < padj.cutoff)
  res.ordered_p <- res.sig[order(res.sig$padj),]
  res.up <- res.ordered_p[ res.ordered_p[,"log2FoldChange"] > 0, ]
  res.down <- res.ordered_p[ res.ordered_p[,"log2FoldChange"] < 0, ]
  n_UpReg <- nrow(res.up)
  n_DownReg <- nrow(res.down)
  topResults <- rbind(res.up[1:n_UpReg, ], res.down[n_DownReg:1, ])
  
  if(save){
    write.csv(topResults, paste0(wd,Sys.Date(),"_SigDEGs_padj-",padj.cutoff,"_", filename,".csv"))
  }
  return(topResults)  
}


#' DrawMAPlot functions cuts of all values with padj = NA, but for this plot they should be included. Add an addtional condition that plots values with NA in grey (or other colour)

DrawMAPlot <- function(res, main="",padj=0.05, xlab="Mean of normalized counts", ylab=expression(log[2]~fold~change), ylim=c(-2,2)){
  #' Draws an MA plot showing the log2 fold changes attributable to a given variable over the mean of normalized counts for all the samples in a DESeqDataSet.
  #' @param res DESeqDataSet, Extracted results from DESeqDataSet using the results() function after DESeq analysis was performed.
  #' @param main String; Title of the Plot [Default: ""]
  #' @param padj Double; Adjusted p-value. [Default: 0.05]
  #' @param xlab String; Title of x label. [Default: "Mean of normalized counts"]
  #' @param ylab String or Expression; Title of y label [Default: expression(log[2]~fold~change)]
  #' @param ylim Integer or double; Limits of the y axis [Default: 2]
  #' @examples
  #' DrawMAPlot(res=res.TvsUn, main="Treated vs Untreated (ashr)")
  res.df <- as.data.frame(res)
  ggplot(data = res.df,aes(x = baseMean, y = log2FoldChange)) +
    geom_point(color = ifelse(res.df$padj < padj, "red", "grey20"),  # add condition for padj = NA
               alpha = ifelse(res.df$padj < padj, 0.5, 0.2),         # add condition for padj = NA
               shape = 16) +
    scale_x_log10(limits=c(1,1000000), breaks = trans_breaks("log10", function(x) 10^x),labels = trans_format("log10", math_format(10^.x))) +
    labs(x = xlab, y = ylab) +
    ylim(ylim) +
    geom_hline(yintercept=0, linetype="dashed", color = "black",size=1) +
    theme_bw() + 
    ggtitle(main)
}



makeVolcanoplot <- function(res.anno, padj.cutoff=0.05, lfc.cutoff=0.58, labelname, labellist, ylim=c(0,30), xlim=c(-5,5), ybreaks=5, xbreaks=10, nudge=-1, segments=FALSE, main){
  #' Generate volcano plot from extracted DESeq results.
  #' @param res.anno DESeqDataSet; Extracted and annotated DESeq results
  #' @param padj.cutoff Numeric; Adjusted p-value. Genes below this value will be highlighted.
  #' @param lfc.cutoff Numeric; Log2 fold change. Genes above this value will be highlighted. LFC is on a log2 scale. An lfc of 0.58 represents a fold change of 1.5.
  #' @param labelname Character; Name of the column used for the labels that will be added to the plot. E.g. "hgnc_symbol".
  #' @param labellist Character vector; Vector with labels that should be used as labels. Has to match the labels that are selected through labelname arg.
  #' @param ylim Numeric vector; Sets limits of the y axis. [Default: "c(0,30)"]
  #' @param xlim Numeric vector; Sets limits of the x axis. [Default: "c(-5,5)"]
  #' @param ybreaks Numeric; Sets number of ticks on the y axis. [Default: 5]
  #' @param xbreaks Numeric; Sets number of ticks on the x axis. [Default: 10]
  #' @param nudge Numeric; Nudge argument for geom_text_repel() function. [Default:-1]
  #' @param segments Logical; Add segments to the plot. [Default: FALSE ]
  #' @param main Character; Add main title to the plot. [Default: ""]
  #' @examples 
  #'
  
  
  # format data
  res <- res.anno %>%
    data.frame() %>%
    mutate(threshold_up = padj < padj.cutoff & abs(log2FoldChange) >= lfc.cutoff) %>% 
    arrange(padj)
  
  # add custom labels
  volcanolabels <- res[,"hgnc_symbol"] 
  volcanolabels[!volcanolabels %in% labellist] <- ""
  
  # plot data
  plot <- ggplot( res, aes(x = log2FoldChange, y = -log10(padj)) ) +
    geom_point(size=1, shape=16, 
               colour = ifelse(res$threshold_up, "firebrick3", "grey20"),
               alpha  = ifelse(res$threshold_up, 0.8, 0.2)  ) +
    geom_text_repel(aes(label = volcanolabels), 
                    max.overlaps = Inf, 
                    min.segment.length = 0,
                    size=3.1,fontface="bold",
                    nudge_y = nudge) +
    ggtitle( main ) +
    xlab( expression(log[2]~fold~change) ) +
    ylab( expression(-log[10]~adjusted~p-value) ) +
    scale_color_manual(values=c("#A9A9A9", "#eb9282")) +
    scale_y_continuous(limits = ylim, breaks=scales::pretty_breaks(n=ybreaks) ) +
    scale_x_continuous(limits = xlim, breaks=scales::pretty_breaks(n=xbreaks) ) +
    theme_bw() +
    theme(legend.position = "none",
          plot.title = element_text(size = rel(1.5), hjust = 0.5),
          axis.title = element_text(size = rel(1.25)),
          panel.grid.major = element_blank(),
          panel.grid.minor = element_blank()
    ) 
  
  if(segments){ 
    plot + geom_segment(aes(x = lfc.cutoff, y = -log10(padj.cutoff), xend = lfc.cutoff, yend = ylim[2]-1 ), linetype="dashed") +
      geom_segment(aes(x = lfc.cutoff, y = -log10(padj.cutoff), xend = xlim[2]-0.5, yend = -log10(padj.cutoff)), linetype="dashed") +
      geom_segment(aes(x = -lfc.cutoff, y = -log10(padj.cutoff), xend = -lfc.cutoff, yend = ylim[2]-1 ), linetype="dashed") +
      geom_segment(aes(x = -lfc.cutoff, y = -log10(padj.cutoff), xend = xlim[1]+0.5, yend = -log10(padj.cutoff)), linetype="dashed")
  }else{
    plot
  }
}






#### Loading data ####
#' Processing of RNAseq data prior to import into DESeq2 using STAR 2.7.3a and featureCounts (from subread 2.0.2). 
#' No trimming was performed. QC performed by novogone

# Metadata/ Sample Table 
colData <- data.frame(
  Sample = factor(c('A03_M2', 'A03_MOX', 
                    'A04_M2', 'A04_MOX',
                    'S02_M2', 'S02_MOX')),
  Condition = factor(rep(c('M2',"MOX"), 3)),
  Donor = factor(c('A03', 'A03', 
                   'A04', 'A04', 
                   'S02', 'S02'))
)
rownames(colData) <- colData$Sample 

# Count matrix
cts <- as.matrix(read.csv("../data/countmatrix.txt", sep="\t",row.names="Geneid"))
colnames(cts) <- colData$Sample # change the long sample names to short sample names
print(paste("Full data set:", all(rownames(colData) %in% colnames(cts)))) # Checking if the sampleTable and count matrix annotations correspond to each other



#### Running differential expression analysis ####
# Parsing count matrix to DESeq2 dataset
ddsCts <- DESeqDataSetFromMatrix(countData = cts,
                                 colData = colData,
                                 design = ~Donor + Condition) #~Donor + Condition
# Running DESeq analysis
dds <- DESeq(ddsCts)


#### Assessing data ####
## Transformation for data set: Variance stabilized transformation
vsd <- vst(dds, blind=TRUE)
vsd_mat <- assay(vsd)


## Per gene standard deviation
# Plotting the per-gene standard deviation (SD, taken across samples) against the rank of the mean for the the variance-stabilizing transformation(vst)
vsd_msd <- meanSdPlot(vsd_mat, ylab="Standard deviation (vst)", plot=FALSE)

png(paste0("../Results/",Sys.Date(),"_VST-Transformation.png"), width=400, height=350 )
vsd_msd$gg + ggtitle("Per gene standard deviation (VST)")
dev.off()


## Hierarchical clustering of samples
vsd_cor  <- cor(vsd_mat)#Computing the pairwise correlation values for transformed counts.


labs <- data.frame(Condition = c(rep(c("M2","MOX"), 3) ))# Preparing annotations and labeling.
rownames(labs) <- colnames(vsd_cor) #all matrices have the same rownames. Note that the rownames are colnames in the correlation matrix
#rownames(annotation) <- colData[["Sample"]]
#annotation
ann_colors = list(Condition = c(M2 ="#eb9282", MOX ="#8cafc8"))  # RA ="#ebb573", PopS ="#eb9282", RO ="#8cafc8"

png(paste0("../Results/",Sys.Date(),"_Hierarchical-sample-clustering.png"), width=400, height=300 )
pheatmap(vsd_cor, annotation = labs, annotation_colors = ann_colors, main = "VST transformed",  silent=F)
dev.off()

## Principal component analysis
pca <- prcomp(t(vsd_mat)) # compute PCA
fviz_screeplot(pca, addlabels = T) + ylim(0,100) + theme_classic() + labs(title = "Variances - PCA (VST transformated counts)\n(Full)", x = "Principal components", y = "% of variance") # Screeplot visualizes the variances accross the different PCs


# Plots of genes contributing to variance for the individual PCs
# PC1
fviz_contrib(pca, choice = "var", axes = 1, top = 15) + 
  theme_classic() + 
  labs(title = "Contribution to PC1", x = "Genes", y = "Contribution (%)") +
  theme(axis.text.x = element_text(angle = 90))

# PC2
fviz_contrib(pca, choice = "var", axes = 2, top = 15) + 
  theme_classic() + 
  labs(title = "Contribution to PC2", x = "Genes", y = "Contribution (%)") +
  theme(axis.text.x = element_text(angle = 90))

# PC3
fviz_contrib(pca, choice = "var", axes = 3, top = 15) + 
  theme_classic() + 
  labs(title = "Contribution to PC3", x = "Genes", y = "Contribution (%)") +
  theme(axis.text.x = element_text(angle = 90))


# PCA plots
png(paste0("../Results/",Sys.Date(),"PCA_PC1+PC2_condition.png"), width=300, height=275 )
makePCAplot(mat=vsd_mat, sampleTable = colData, colorby="Condition", PC.x = 1, PC.y = 2, main = "PC1 and PC2 by condition")
dev.off()

png(paste0("../Results/",Sys.Date(),"PCA_PC1+PC2_donor.png"), width=300, height=275 )
makePCAplot(mat=vsd_mat, sampleTable = colData, colorby="Donor", PC.x = 1, PC.y = 2, main = "PC1 and PC2 by donor")
dev.off()

png(paste0("../Results/",Sys.Date(),"PCA_PC1+PC3_condition.png"), width=300, height=275 )
makePCAplot(mat=vsd_mat, sampleTable = colData, colorby="Condition", PC.x = 1, PC.y = 3, main = "PC1 and PC3 by condition")
dev.off()

png(paste0("../Results/",Sys.Date(),"PCA_PC1+PC3_donor.png"), width=300, height=275 )
makePCAplot(mat=vsd_mat, sampleTable = colData, colorby="Donor", PC.x = 1, PC.y = 3, main = "PC1 and PC3 by donor")
dev.off()




## Diagnostic plots
# Cooks distances
png(paste0("../Results/",Sys.Date(),"_Cooks-distance.png"), width=300, height=275 )
par(mar=c(5,5,1,1))
boxplot(log10(assays(dds)[["cooks"]]), range=0, las=1, main="Cook's distance")
dev.off()

# Dispersion estimates
png(paste0("../Results/",Sys.Date(),"_Dispersion-estimates.png"), width=300, height=275 )
par(mar=c(5,5,2,2))
plotDispEsts(dds) 
title("Dispersion estimates")
dev.off()


#### DGE results ####

## Verifying size factors
design <- design(dds)
print(paste("Design: ~", design[2]))
sizefactors <- sizeFactors(dds)
print("Size factors:")
print(sizefactors)

## Setting contrast and extracting results
contrast <- c("Condition", "MOX","M2")
padj = 0.05
res.unshrunken <- results(dds,  contrast = contrast,  alpha = padj)

# Summary oxLDL-treated M2 macrophages vs untreated M2 macrophages")
summary(res.unshrunken) 


## LFC shrinkage
res.ashr  <- lfcShrink(dds, type = "ashr", contrast=contrast,  res = res.unshrunken) 



plotMA(res.unshrunken, ylim=c(-6,6)) + title("MA plot (unshrunken)")
plotMA(res.ashr, ylim=c(-6,6))  + title("MA plot (shrunken)")


# clean NA values from data
res  <- na.omit(res.ashr)



## Annotation
ensembl <- useEnsembl(biomart = "genes",
                      dataset = "hsapiens_gene_ensembl",
                      version = 104) # the same version used as reference genome for alignment with STAR

# Query biomart for annotation
#' Add information on how and where to get the gtf file from
#' Creating the transcript database for annotation
gtffile <- "../data/Homo_sapiens.GRCh38.104.gtf.gz"  
txdb <- makeTxDbFromGFF(gtffile,
                        format="auto",
                        dataSource="ensembl.org GRCh38.p13 release 104",
                        organism="Homo sapiens")

attributes <- c("ensembl_gene_id","hgnc_symbol","entrezgene_id","chromosome_name","gene_biotype","description")
GeneIDs <- keys(txdb, keytype="GENEID") # txdb has been generated from from the GFF file corresponding to the reference genome used for alignment

annotation <- getBM(attributes = attributes,
                    filters = c("ensembl_gene_id"),
                    values = GeneIDs,
                    mart = ensembl)

res.anno  <- annotateResults(res, anno=annotation) # custom function


## Filtering and sorting of significant genes
res.sig  <- getSigDEGs(res.anno,  padj.cutoff=padj, save=T, wd="../results/", filename="Treg_MOX-vs-M2")
#View(res.sig)



## Visualising DGE results

# Heatmaps
#' Heatmaps of significant differentially expressed genes.
#' Extracting the vst transformed counts to generate Heatmaps of sig. DEGs.
# select the rows with significant genes
sig.genes <- res.sig[res.sig$padj < padj,]["hgnc_symbol"] # get significant genes
sig.symbol <- sig.genes[["hgnc_symbol"]]
sig.ensembl <- rownames(sig.genes) 
norm_countsig <- data.frame(vsd_mat)[sig.ensembl,] # select the sig genes from the transformed count matrix

png(paste0("../Results/",Sys.Date(),"_Heatmap.png"), width=600, height=1800, res=120 )
pheatmap(norm_countsig,         
         border_color = NA,
         color = colorRampPalette(rev(brewer.pal(11,"RdBu")))(255),
         cluster_rows = T,         
         labels_row = sig.symbol,     
         scale = "row",
         show_rownames = T,       
         #clustering_distance_cols = "euclidean",
         clustering_method = "average",
         fontsize_row = 5, 
         main = "Heatmap of sig DEGs"
)
dev.off()


# Volcano plots
genelist = c("ABCA7","VMO1")
png(paste0("../Results/",Sys.Date(),"_VolcanoPlot.png"), width=500, height=500, res=120 )
makeVolcanoplot(res.anno=res.anno, padj.cutoff=0.05, lfc.cutoff=0.58, labelname="hgnc_symbol", labellist=genelist, ylim=c(0,10), xlim=c(-1.2,1.0), ybreaks=5,xbreaks=10, segments=F, main="oxLDL-treated M2 Macrophages \nvs untreated M2 macrophages")
dev.off()



#### Functional analysis ####
#'Functional analysis will be performed with the `ClusterProfiler` package. 

## Preparing input data
#' GSEA and ORA require the data to be in specific formats. The next few sections are used to extract the relevant genes and parse them into the right format for the different analyses.

#' 1. List of DEGs (ENSEMBL IDs)
#' Significant results which will be used for ORA with GO. Create background dataset for hypergeometric testing using all genes tested for significance in the results
MOXvM2_sig.ensembl <- as.character(rownames(subset(res.anno, padj < 0.05 ))) # vector of sig DEGs (ENSEMBL IDs) for ORA
universe.ensembl <- as.character(rownames(res.anno))


#' 2. Ranked Genelist for GSEA (ENSEMBL IDs)
#' Prepare Gene list: 1. numeric vector: FC; 2. named vector: gene IDs (ENSEMBL) 3. sorted vector: number should be sorted in decreasing order
foldchanges <- res.anno[,"log2FoldChange"] # take shrunken log2 fold changes
names(foldchanges) <- as.character(rownames(res.anno)) # can be used for ORA of GO terms as well
rankedMOXvM2_all.ensembl <- sort(foldchanges, decreasing = T)



## Overrepresentation analysis - GO
eGO <- enrichGO(gene = MOXvM2_sig.ensembl, 
                     universe = universe.ensembl,   
                     keyType = "ENSEMBL",           # depends on database - may have different names
                     OrgDb = org.Hs.eg.db,          
                     ont = "BP",                    # BP, CC, MF
                     pAdjustMethod = "BH",          # Benjamini-Hochberg
                     pvalueCutoff = 0.05,
                     qvalueCutoff = 0.05,           
                     #minGSSize = 20,               # minimal size of genes annotated by Ontology term for testing.
                     readable = TRUE)
# save results
write.csv(data.frame(eGO), paste0("../Results/",Sys.Date(),"_GO-enrichment_MOX-vs-M2.csv"))


# Formatting the GO enrichment results and calculating gene ratio for plotting
enrichment <- data.frame(eGO)
# Gene ratio (number of genes related to GO term / total number of significant genes)
generatio <- enrichment["GeneRatio"]
generatio <- separate(data=generatio, col=GeneRatio, into = c("GeneRatio_k","GeneRatio_n"), sep="/" ) # separate gene Ratio column
generatio <- sapply(generatio, as.numeric)
enrichment$GeneRatio <- generatio[,1] / generatio[,2]
# Background ratio ()
bgratio <- enrichment["BgRatio"]
bgratio <- separate(data=bgratio, col=BgRatio, into = c("BgRatio_M","BgRatio_N"), sep="/" ) # separate gene Ratio column
bgratio <- sapply(bgratio, as.numeric)
enrichment$BgRatio <- bgratio[,1] / bgratio[,2]
# rearranging order
enrichment <- arrange(enrichment, -GeneRatio)


# Plot top results of GO analysis
png(paste0("../Results/",Sys.Date(),"_GO-results.png"), width=450, height=400)
p <- ggplot(data=enrichment[1:25,], aes(x=GeneRatio, y=reorder(Description,GeneRatio), color=p.adjust)) # size=bgRatio
p  + geom_point(stat="identity", size=5) + 
  scale_colour_viridis(begin=0, end=1) + 
  labs(color = "FDR-adjusted p-value") + 
  scale_x_continuous(name="Gene ratio", limits=c(0.05,0.15)) +
  ylab("GO term") + 
  ggtitle("GO enrichment") +
  theme_bw()
dev.off()


# Plotting custom results (e.g. pathways of interest)
terms <- c("GO:0006082", "GO:0043436", "GO:0016053", "GO:0019752", "GO:0008610", "GO:0006631", "GO:0008202", "GO:0045834", "GO:0006641", "GO:0044255", "")
enrichment.subset <- enrichment[enrichment$ID %in% terms,]
png(paste0("../Results/",Sys.Date(),"_GO-results_custom.png"), width=450, height=200)
p <- ggplot(data=enrichment.subset, aes(x=GeneRatio, y=reorder(Description,GeneRatio), color=p.adjust)) # size=bgRatio
p  + geom_point(stat="identity", size=5) + 
  scale_colour_viridis(begin=0, end=1) + 
  labs(color = "FDR-adjusted p-value") + 
  scale_x_continuous(name="Gene ratio", limits=c(0.02,0.15)) +
  ylab("GO term") + 
  ggtitle("GO enrichment") +
  theme_bw()
dev.off()



## Geneset enrichment analysis
#' Retrieving all human gene sets from msigdbr

msigdb_df <- msigdbr(species = "Homo sapiens") # all msigDB entries
#head(msigdb_df)

# all gene sets
#all_t2g <- dplyr::select(msigdb_df, c("gs_name","ensembl_gene"))

# Hallmark
h <- msigdb_df[(msigdb_df[,"gs_cat"] == "H"),]
h_t2g <- dplyr::select(h, c("gs_name","ensembl_gene"))

gsem <- GSEA(rankedMOXvM2_all.ensembl,
                  TERM2GENE = h_t2g,
                  eps = 0,
                  pvalueCutoff = 0.05,
                  pAdjustMethod = "BH",
                  minGSSize = 30,
                  maxGSSize = 500,
                  nPerm = 10000,
                  verbose = F)


# save results
write.csv(data.frame(gsem), paste0("../Results/",Sys.Date(),"_GSEA_MOX-vs-M2.csv"))

png(paste0("../Results/",Sys.Date(),"_GSEA_p53.png"), width=670, height=250)
gseaplot2(gsem, geneSetID = "HALLMARK_P53_PATHWAY", title = "HALLMARK: P53 PATHWAY \n(oxLDL treated macrophages vs untreated macrophages)", subplots= 1:2, pvalue_table = T, ES_geom = "line" )
dev.off()

png(paste0("../Results/",Sys.Date(),"_GSEA_Inflammatory-response.png"), width=670, height=300)
gseaplot2(gsem, geneSetID = "HALLMARK_INFLAMMATORY_RESPONSE", title = "HALLMARK: INFLAMMATORY RESPONSE \n(oxLDL treated macrophages vs untreated macrophages)", subplots= 1:2, pvalue_table = T, ES_geom = "line" )
dev.off()

png(paste0("../Results/",Sys.Date(),"_GSEA_ROS.png"), width=670, height=300)
gseaplot2(gsem, geneSetID = "HALLMARK_REACTIVE_OXYGEN_SPECIES_PATHWAY", title = "HALLMARK: ROS pathway \n(oxLDL treated macrophages vs untreated macrophages)", subplots= 1:2, pvalue_table = T, ES_geom = "line" )
dev.off()

png(paste0("../Results/",Sys.Date(),"_GSEA_Hypoxia.png"), width=670, height=300)
gseaplot2(gsem, geneSetID = "HALLMARK_HYPOXIA", title = "HALLMARK: Hypoxia \n(oxLDL treated macrophages vs untreated macrophages)", subplots= 1:2, pvalue_table = T, ES_geom = "line" )
dev.off()